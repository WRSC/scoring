#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Analyse the result of a area scanning attempt
This script is for use independent of ROS!


man:
    analyse_are_scanning path/to/yaml/parameter/file.yaml  path/to/gps/log.cvs
"""

import csv
import sys
# import yaml
# from sailing_robot.navigation import Navigation

from LatLon import LatLon
from pyproj import Proj
import numpy as np

utm_zone = 30

projection = Proj(proj='utm', zone=utm_zone, ellps='WGS84')

def latlon_to_utm(lat, lon):
    """Returns (x, y) coordinates in metres"""
    return projection(lon, lat)

def utm_to_latlon(x, y):
    """Returns a LatLon object"""
    lon, lat = projection(x, y, inverse=True)
    return LatLon(lat, lon)



# CSV values
# hhmmssdd
# Lat *10^^7
# Lon *10^^7

#   C
#   +-+-+-+-+-+
#   +-+-+-+-+-+
#   +-+-+-+-+-+
#   A         B
# 
#  y^
#   |
#   +-> x
#

# Number of subdivision of the grid
subY = 5
subX = 10


# gps log file given as the 2nd argument
# cvs_file = sys.argv[2]


wpA = (1.5, -0.2)
wpB =
wpC = 

wpA_utm = latlon_to_utm(wpA[0], wpA[1])
wpB_utm = latlon_to_utm(wpB[0], wpB[1])
wpC_utm = latlon_to_utm(wpC[0], wpC[1])


# Unit vector AB
vAB = np.array([wpB_utm[0] - wpA_utm[0], wpB_utm[1] - wpA_utm[1]])
AB = np.linalg.norm(vAB)
vAB = vAB/AB


# Unit vector AC
vAC = np.array([wpC_utm[0] - wpA_utm[0], wpC_utm[1] - wpA_utm[1]])
AC = np.linalg.norm(vAC)
vAC = vAC/AC
vAB_orth = vAC

# Unit vector orth to AB
# vAB_orth = np.array([-vAB[1], vAB[0]])



# Read log files
teamNB = len(sys.argv) - 1
output_array = np.zeros((subX, subY, teamNB))
for teamID, cvs_file in enumetate(sys.argv[1:]):#TODO all csv files
    position_utm = []
    with open(cvs_file) as logfile:
        data = csv.reader(logfile, delimiter=',')
        for row in data:
            latitude = float(row[1])/10**7
            longitude = float(row[2])/10**7
            position_utm.append(latlon_to_utm(latitude, longitude))


    for point in position_utm: 
        # projection of point in the (wpA_utm; vAB,vAB_orth) base
        point_base = [point[0] - wpA_utm[0], point[1] - wpA_utm[1]]
        point_i = np.dot(point_base, vAB)*subX/2/AB
        point_j = np.dot(point_base, vAB_orth)*subY/2/AC
        
        if point_i < 0 or point_j < 0 or point_i > subX or point_j > subY:
            continue 
        
        output_array[int(point_i)][int(point_j)][teamID] = 1

weight_array = np.zeros((subX, subY))
for i in range(subX):
    for j in range(subY):
        weight_array[i,j] = 1.0/sum(output_array[i][j])


# Point counting

team_score = np.zeros(teamNB)
for i in range(subX):
    for j in range(subY):
        for teamID in range(teamNB):
            team_score[teamID] += weight_array[i][j] * output_array[i][j][teamID]

print(team_score)


# Output the grid
# print u'┌─' + u'┬─'*(subX-1) + u'┐'
# score = 0
# for i in range(sub):
#     row = ''
#     for j in range(sub):
#         if output_array[i][j] == 1:
#             if i<=(sub/2 -1) or j>(sub/2 -1):
#                 score += 1
#                 row = row + u"│X"
#             else:
#                 row = row + u"│o"
#         else:
#             row = row + u"│ "
#     print row + u'│'
#     if i<(sub-1):
#         print u'├─' + u'┼─'*(sub-1) + u'┤'
# print u'└─' + u'┴─'*(sub-1) + u'┘'

# print 'Score: ' +  str(score) + '/' + str(sub*sub*3/4)
