#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
Analyse the result of a set of area scanning attempts.

This is the most complex analysis, because the score for each attempt depends
on other attempts.

Briefly, the idea is that each square is worth one point, but that point may
be divided among boats that visited the same square. The idea is to make the
least visited squares more valuable, encouraging boats to collectively scan
more of the grid. See the rules for more details.

We gave each class a time window, but allowed shorter attempts later in the day.
Attempts within the time window were scored against other attempts in the same window.
Later attempts were scored against attempts in the window,
excluding earlier attemtps by the same boat.

Usage:

    ./analyse_area_scanning master.csv

The master CSV is a CSV file listing the attempts made by boats in one class.
It's expected to have columns boat_name, in_window and filename (pointing to
the GPS trace for that attempt).
"""

import csv
import sys
import pandas as pd
import collections
from fractions import Fraction
import json

from pyproj import Proj
import numpy as np

# Your UTM zone depends on your longitude; see http://www.dmap.co.uk/utmworld.htm
utm_zone = 30

projection = Proj(proj='utm', zone=utm_zone, ellps='WGS84')

def latlon_to_utm(lat, lon):
    """Returns (x, y) coordinates in metres"""
    return projection(lon, lat)

def utm_to_latlon(coord):
    """Returns (lat, lon) in degrees"""
    lon, lat = projection(coord[0], coord[1], inverse=True)
    return lat, lon

#   C         D
#   +-+-+-+-+-+
#   +-+-+-+-+-+
#   +-+-+-+-+-+
#   A         B
# 
#  y^
#   |
#   +-> x
#

# Number of subdivisions of the grid
subY = 58
subX = 45
cell_size = 4  # metres along side of one grid cell

wpC = (50.8210729998,-1.31465664793)
wpD = (50.8222207292,-1.31285527881)
wpA = (50.8196023064,-1.31232136805)
wpB = (50.82075,-1.31052)

################################################################################

# Convert all coordinates to UTM, so we can work with metres on a flat plane
wpA_utm = latlon_to_utm(wpA[0], wpA[1])
wpB_utm = latlon_to_utm(wpB[0], wpB[1])
wpC_utm = latlon_to_utm(wpC[0], wpC[1])

# Unit vector AB
vAB = np.array([wpB_utm[0] - wpA_utm[0], wpB_utm[1] - wpA_utm[1]])
AB = np.linalg.norm(vAB)
vAB = vAB/AB

# Unit vector AC
vAC = np.array([wpC_utm[0] - wpA_utm[0], wpC_utm[1] - wpA_utm[1]])
AC = np.linalg.norm(vAC)
vAC = vAC/AC
vAB_orth = vAC

def cell_ij_to_coord(i,j):
    """Get the (lat, lon) of the 4 corners of a grid cell"""
    A = wpA_utm + vAB*cell_size*i + vAB_orth*cell_size*j
    B = A+vAB_orth*cell_size
    C = B+vAB*cell_size
    D = A+vAB*cell_size
    A = utm_to_latlon(A)
    B = utm_to_latlon(B)
    C = utm_to_latlon(C)
    D = utm_to_latlon(D)
    return A,B,C,D


def generate_visit_set(filename):
    with open(filename) as logfile:
        data = csv.reader(logfile, delimiter=',')
        position_utm = []
        for row in list(data)[1:]:
            latitude = float(row[1])
            longitude = float(row[2])
            position_utm.append(latlon_to_utm(latitude, longitude))

    outputs = set()

    for point in position_utm: 
        # projection of point in the (wpA_utm; vAB,vAB_orth) base
        point_base = [point[0] - wpA_utm[0], point[1] - wpA_utm[1]]
        point_i = np.dot(point_base, vAB)*subX/AB
        point_j = np.dot(point_base, vAB_orth)*subY/AC
        
        if point_i < 0 or point_j < 0 or point_i > subX or point_j > subY:
            continue 

        outputs.add((int(point_i), int(point_j)))
        #output_array[int(point_i)][int(point_j)] = 1
    return outputs


CellVisitors = collections.namedtuple('CellVisitors', 'in_window out_of_window')

# read master csv
# Master data columns:
#    filename
#    boat_name
#    in_window
master_data = pd.read_csv(sys.argv[1])
master_data['visit_set'] = master_data.filename.apply(generate_visit_set)
attempt_per_cell = collections.defaultdict(int)
for row in master_data.itertuples():
    print(row.filename, len(row.visit_set))
    for cell_pos in row.visit_set:
        attempt_per_cell[cell_pos] += 1

# Dump out data for plotting heat maps of how often cells were visited.
data = []
for cell, count in attempt_per_cell.items():
    data.append([cell_ij_to_coord(cell[0],cell[1]), count])
with open("heat_map_data"+sys.argv[1]+".json",'w') as f:
    json.dump(data,f)

# Build map of what teams visited which cells, in their in-window and out-of-window attempts
cell_visits = collections.defaultdict(lambda: CellVisitors(set(), set()))
for row in master_data[master_data.in_window].itertuples():
    for cell in row.visit_set:
        cell_visits[cell].in_window.add(row.boat_name)

for row in master_data[~master_data.in_window].itertuples():
    for cell in row.visit_set:
        cell_visits[cell].out_of_window.add(row.boat_name)
 
boat_total_points_in_window = collections.defaultdict(lambda: 0)
boat_total_points_out_of_window = collections.defaultdict(lambda: 0)

for row in master_data[master_data.in_window].itertuples():
    for cell in row.visit_set:
        boat_total_points_in_window[row.boat_name] += Fraction(1, len(cell_visits[cell].in_window))

for row in master_data[~master_data.in_window].itertuples():
    for cell in row.visit_set:
        boat_total_points_out_of_window[row.boat_name] += Fraction(1, len(cell_visits[cell].in_window | cell_visits[cell].out_of_window))

print("in window")
for boat, total_points in sorted(boat_total_points_in_window.items()):
    print(boat, float(total_points))

print("")
print("out of window")
for boat, total_points in sorted(boat_total_points_out_of_window.items()):
    print(boat, float(total_points))
